(** {1 JSON Web Key}*)
module Jwk : sig
  (**
  {1 Public keys}
  These keys are safe to show and should be used to verify signed content.
  *)
  module Pub : sig
    type t = {
      alg : string option;
      kty : string;
      use : string option;
      n : string;
      e : string;
      kid : string;
      x5t : string option;
    }
    (**
    [t] describes a Public JSON Web Key
    *)

    val of_pub : Nocrypto.Rsa.pub -> (t, [ `Msg of string ]) result
    (**
    [of_pub pub] takes a public key generated by Nocrypto and returns a result t or a message of what went wrong.
    *)

    val to_pub : t -> (Nocrypto.Rsa.pub, [ `Msg of string ]) result
    (**
    [to_pub t] takes a public JWK and returns a result [Nocrypto.Rsa.pub] or a message of what went wrong.
    *)

    val of_pub_pem : string -> (t, [ `Msg of string ]) result
    (** 
    [of_pub_pem pem] takes a public PEM as a string and returns a result a result t or a message of what went wrong.
    *)

    val to_pub_pem : t -> (string, [ `Msg of string ]) result
    (**
    [to_pub_pem t] takes a public JWK and returns a result public PEM string or a message of what went wrong.
    *)

    val to_json : t -> Yojson.Safe.t
    (**
    [to_json t] takes a [t] and returns a [Yojson.Safe.t]
    *)

    val of_json : Yojson.Safe.t -> (t, [ `Msg of string ]) result
    (**
    [of_json json] takes a [Yojson.Safe.t] and returns a [t]
    *)

    val of_string : string -> (t, [ `Msg of string ]) result
    (**
    [of_string json_string] takes a JSON string representation and tries to return a [t]
    *)

    val to_string : t -> string
    (**
    [to_string t] takes a t and returns a JSON string representation
    *)
  end

  (**
  {1 Private keys}

  These keys are not safe to show and should be used to sign content.
  *)
  module Priv : sig
    type t = {
      kty : string;
      n : string;
      e : string;
      d : string;
      p : string;
      q : string;
      dp : string;
      dq : string;
      qi : string;
      alg : string option;
      kid : string;
    }
    (**
    [t] describes a Private JSON Web Key
    *)

    val of_priv : Nocrypto.Rsa.priv -> (t, [ `Msg of string ]) result
    (**
    [of_priv priv] takes a private key generated by Nocrypto and returns a result t or a message of what went wrong.
    *)

    val to_priv : t -> (Nocrypto.Rsa.priv, [ `Msg of string ]) result
    (**
    [to_priv t] takes a private JWK and returns a result Nocrypto.Rsa.priv or a message of what went wrong.
    *)

    val of_priv_pem : string -> (t, [ `Msg of string ]) result
    (**
    [of_priv_pem pem] takes a PEM as a string and returns a result a result t or a message of what went wrong.
    *)

    val to_priv_pem : t -> (string, [ `Msg of string ]) result
    (**
    [to_priv_pem t] takes a private JWK and returns a result PEM string or a message of what went wrong.
    *)

    val to_json : t -> Yojson.Safe.t
    (**
    [to_json t] takes a [t] and returns a [Yojson.Safe.t]
    *)

    val of_json : Yojson.Safe.t -> (t, [ `Msg of string ]) result
    (**
    [of_json json] takes a [Yojson.Safe.t] and returns a [t]
    *)

    val of_string : string -> (t, [ `Msg of string ]) result
    (**
    [of_string json_string] takes a JSON string representation and tries to return a [t]
    *)

    val to_string : t -> string
    (**
    [to_string t] takes a t and returns a JSON string representation
    *)
  end
end

(**
{1 JSON Web Key Set}
*)
module Jwks : sig
  type t = { keys : Jwk.Pub.t list }
  (**  [t] describes a Private JSON Web Key Set *)

  val to_json : t -> Yojson.Safe.t
  (**
  [to_json t] takes a [t] and returns a [Yojson.Safe.t]
  *)

  val of_json : Yojson.Safe.t -> t
  (**
  [of_json json] takes a [Yojson.Safe.t] and returns a [t].
  Keys that can not be serialized safely will be removed from the list
  *)

  val of_string : string -> t
  (**
    [of_string json_string] takes a JSON string representation and returns a [t].
    Keys that can not be serialized safely will be removed from the list
    *)

  val to_string : t -> string
  (**
  [to_string t] takes a t and returns a JSON string representation
  *)
end

module Header : sig
  type t = {
    alg : [ `RS256 | `none | `Unknown ];
    jku : string option;
    jwk : Jwk.Pub.t option;
    kid : string option;
    x5t : string option;
    x5t256 : string option;
    typ : string option;
    cty : string option;
  }
  (**
    The [header] has the following properties:
    - [alg] Algorithm - RS256 and none is currently the only supported algs
    - [jku] JWK Set URL
    - [jwk] JSON Web Key
    - [kid] Key ID - We currently always expect this to be there, this can change in the future
    - [x5t] X.509 Certificate SHA-1 Thumbprint
    - [x5t#S256] X.509 Certificate SHA-256 Thumbprint
    - [typ] Type
    - [cty] Content Type
    Not implemented:
    - [x5u] X.509 URL
    - [x5c] X.509 Certficate Chain
    - [crit] Critical

    {{: https://tools.ietf.org/html/rfc7515#section-4.1 } Link to RFC }
    *)

  val make_header : ?typ:string -> Jwk.Pub.t -> t
  (**
  [make_header jwk] creates a header with [typ], [kid] and [alg] set based on the public JWK
  *)

  val of_string : string -> (t, [ `Msg of string ]) result

  val to_string : t -> (string, [ `Msg of string ]) result

  val to_json : t -> Yojson.Safe.t

  val of_json : Yojson.Safe.t -> (t, [ `Msg of string ]) result
end

(**
  {1 JSON Web Signature}

  {{: https://tools.ietf.org/html/rfc7515 } Link to RFC }
*)
module Jws : sig
  type signature = string

  type t = { header : Header.t; payload : string; signature : signature }

  val validate : jwks:Jwks.t -> t -> (t, [ `Msg of string ]) result
  (**
  [validate jwks t] validates the signature
  *)

  val sign :
    header:Header.t ->
    payload:string ->
    Nocrypto.Rsa.priv ->
    (t, [ `Msg of string ]) result
  (**
  [sign header payload priv] creates a signed JWT from [header] and [payload]

  We will start using a private JWK instead of a Nocrypto.Rsa.priv soon
  *)
end

(**
{1 JSON Web Token}
*)
module Jwt : sig
  type payload = Yojson.Safe.t

  type claim = string * Yojson.Safe.t

  val empty_payload : payload

  type t = { header : Header.t; payload : payload; signature : Jws.signature }

  val add_claim : string -> Yojson.Safe.t -> payload -> payload

  val to_string : t -> (string, [ `Msg of string ]) result

  val of_string : string -> (t, [ `Msg of string ]) result

  val to_jws : t -> (Jws.t, [ `Msg of string ]) result

  val of_jws : Jws.t -> (t, [ `Msg of string ]) result

  val validate : jwks:Jwks.t -> t -> (t, [ `Msg of string ]) result
  (**
  [validate jwks t] checks if the JWT is valid and then calls Jws.validate to validate the signature
  *)

  val sign :
    header:Header.t ->
    payload:payload ->
    Nocrypto.Rsa.priv ->
    (t, [ `Msg of string ]) result
  (**
  [sign header payload priv] creates a signed JWT from [header] and [payload]
  
  We will start using a private JWK instead of a Nocrypto.Rsa.priv soon
  *)
end
